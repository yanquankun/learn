关键词： `AST` `字节码` `机器码` `Parse` `Ignition` `TurboFan`

**前因**

作为一个前端开发者，我们的代码大部分场景是运行在浏览器上的，那么浏览器是如何解析我们的 js 代码的呢？我们经常听到的`AST`是做什么的呢？解析 js 又分为哪几个阶段呢？

**后果**

### 编程语言类型

1. 编译型语言
   在代码运行前编译器直接将对应的代码转换成机器码，运行时不需要再重新翻译，直接可以使用编译后的结果，如 C++ Java

2. 解释型语言
   在运行时，才会进行代码转换为机器码，所以速度上慢与编译型语言，如 JS Ruby

`那么为了提供解释型语言的运行速度，各大厂商也是绞尽脑汁，不断努力，目前最好的当数V8引擎，它引入了java虚拟机和C++编译器等技术`

### V8

> 常见的 js 解析器：

- JavaScriptCore
- chakra
- V8

对于这些引擎，最常用的是 V8 引擎，也就是 Chrome 的内核，Nodejs 也是基于此引擎进行开发的。它在解析 JS 代码时，经历如下过程：

1. `Parse阶段：` V8 解析 js 为 AST（抽象语法树）
2. `Ignition阶段：` 通过解释器将 AST 转换为字节码
3. `TurboFan阶段：` 通过 Ignintion 收集到的重要信息，将字节码优化为可以执行的机器码
4. `GC阶段：` 进行垃圾回收，释放内存空间

### AST

AST 分为两个阶段：

- `词法解析`： 将代码进行拆解，转换为词法单元，成为`token`

- `语法解析`：将一个个的`token`拼装成一个由根元素为节点的逐级嵌套的语法结构树，也就是抽象语法树

**那么 AST 具有哪些作用呢**

1. JS 反编译，语法解析
2. `Babel`编译`ES`语法
3. 代码高亮
4. 关键字匹配
5. 代码压缩

### Ignition 阶段

这个阶段，主要的作用则是将`AST`转换为`字节码`，最早`V8`没有这个过程，直接将`AST`转换为`机器码`，但这种会导致内存占用过大，因此多了一个这个过程。

`字节码`是介于`AST`和`机器码`中间的一种代码，无法直接执行，需要转换为`机器码`后才能被机器执行

### 机器码

这个过程，是对字节码的一个优化过程，比如重复执行的一段代码，会被`TurboFan`编译器进行优化为对应的机器码。`TurboFan`是`JIT`优化的编译器，由于`V8是多线程`的，所以在`TurboFan`的编译线程和生成字节码不是同一个线程，这使得`Ignition`和`TurboFan`可以搭配使用，互不影响

### GC

这个阶段，大家已经很了解了，就不再赘述了 😄

### 流程图

![V8解析js流程.png](https://oss.yanquankun.cn/oss-cdn/V8%E8%A7%A3%E6%9E%90js%E6%B5%81%E7%A8%8B.png!watermark)

**结尾**

最后，给大家附送下[ECMA 官方文档](https://tc39.es/ecma262/#sec-intro)以及[V8 引擎源码](https://chromium.googlesource.com/v8/v8.git/+/main/)
