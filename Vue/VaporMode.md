> Vue 3.6 带来了一个意义重大的更新： **Vapor Mode** 渲染模式
>
> *并不只是一次常规的功能升级，而是 Vue 渲染机制的一次“底层重构”尝试。它试图用更轻量、更贴近原生 DOM 的方式，取代我们熟悉的虚拟 DOM，从而进一步释放 Vue 的性能潜力。*

### 虚拟DOM

在早期的 Web 开发中，开发者需要手动操作 DOM。每次状态变化，都得写一堆原生 DOM API 的代码，既繁琐又容易出错，性能也不理想。

为了改善这个问题，React 最早提出了“虚拟 DOM”的概念：用 JavaScript 在内存中模拟出一棵 DOM 树，当状态发生变化时，先更新虚拟 DOM，然后通过 diff 算法找出差异，最后再“精确地”更新真实 DOM。

Vue 的传统渲染逻辑也是类似：

1. 数据变化后，组件重新执行 `render()` 函数，生成新的虚拟 DOM。
2. Vue 对比新旧虚拟 DOM，找出变化。
3. 最后将变化映射到真实 DOM 上。

这个机制极大地提升了开发效率，使 UI 构建变得更声明式。但随着项目规模变大，虚拟 DOM 也逐渐暴露出了一些短板：

- **内存占用高**：虚拟 DOM 树常驻内存，资源压力大；
- **性能开销大**：即使只改一个字段，也可能触发整棵子树的 diff；
- **首次渲染慢**：要先构造虚拟 DOM，再创建真实 DOM；
- **调试困难**：虚拟 DOM 增加了抽象层，排查问题不直观；
- **无法用上浏览器的原生优化**：浏览器对 DOM 更新本就有优化策略，而虚拟 DOM 反而成了中间障碍。

**于是vue团队期望可以绕开虚拟DOM，直接操作真实DOM，这就是Vapor Mode诞生的原因**

### Vapor Mode

> *Vapor Mode 是 Vue 3.6 新引入的一种渲染模式，设计灵感来自 Solid.js*
>
> **不再构建虚拟 DOM，也不再 diff 树，而是在编译阶段就把模板转成“操作真实 DOM 的代码”。**

简单来说：你写的 `<template>` 代码，会被 Vue 编译器转成一套精准的、数据驱动的 DOM 操作指令。运行时完全跳过虚拟 DOM 这一步，直接操作页面元素。

##### Vapor Mode 和传统模式的差别

![图片](https://oss.yanquankun.cn/oss-cdn/img/640!watermark)

##### How to work？

我们来分步骤拆解一下 Vapor Mode 的渲染流程：

1. **编译阶段分析模板**：Vue 编译器在构建时会分析 `<template>` 中的内容，识别哪些是静态的、哪些是响应式的。
   - **静态部分**：如 `<div>` 标签，编译器会生成一次性创建它们的代码，运行时无需理会。
   - **动态绑定**：如 `{{ count }}`，每一个绑定都会生成一个独立的 “更新函数”。
2. **创建“Effect 函数”**：每个响应式绑定都会生成一个独立的副作用函数（effect）：
   - 它知道自己依赖哪个响应式数据（如 `ref` 或 `reactive` 属性``）
   - 它知道自己要操作哪个 DOM 节点（如某个 `<p>`）
   - 它知道要执行的操作是什么（如更新 `textContent`、修改 `class` 或调整 `style`）

也就是说，一旦数据变化，只会触发该数据相关的 DOM 更新逻辑。

##### 举个🌰

```vue

<template>
  <div>
    <h1>前端充电宝</h1>
    <p>计数器: {{ count }}</p>
    <button @click="count++">增加</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'
const count = ref(0)
</script>
```

- 在 **传统模式** 中，点击按钮时：
  1. Vue 会重新执行 `render()`，生成一份新的虚拟 DOM；
  2. 然后 diff，找出 `count` 变了；
  3. 最后再更新 `<p>` 标签的文本。
- **在 Vapor Mode 中**：
  1. 编译时，Vue 识别出 `<p>` 的文本绑定了 `count`；
  2. 它为这个绑定生成一个更新函数，比如：

```vue
effect(() => {
  pElement.textContent = '计数器: ' + count.value
})
```

		3. 当点击按钮后，`count` 更新，这个 effect 就直接执行，精准更新 `<p>` 的内容。

全程没有虚拟 DOM，也没有 diff，对性能极为友好

##### 它的优势是什么？

- **更新速度快**：跳过 diff，只更新真正变化的 DOM；
- **占用更少内存**：不再维护虚拟 DOM；
- **首次渲染更快**：直接创建真实 DOM；
- **打包体积更小**：可移除虚拟 DOM 相关代码；
- **按需启用**：可在组件级别使用 Vapor，不影响全局；

##### Virtual Dom 过时了吗？

*答案肯定是否定的*

Vue 并没有一刀切，而是走了“混合动力”路线：

- Vapor Mode 是可选的
- `<script setup>` 中使用 `vapor` 关键字即可开启
- 也可以通过 `createVaporApp()` 创建纯 Vapor 应用

这意味着你可以：

- 在关键性能组件里启用 Vapor
- 在其它部分继续使用虚拟 DOM

**什么时候用虚拟 DOM ，什么时候用 Vapor？**

- **继续使用虚拟 DOM 的场景**：
  - 组件结构动态复杂，依赖 render 函数
  - 项目已成规模，虚拟 DOM 的性能已满足需求
- **拥抱 Vapor Mode 的场景**：
  - 组件结构静态明确，状态变化点固定
  - 对性能要求极高：如移动端、嵌入式、实时数据 UI
  - 构建时间允许进行编译优化分析

#### 或许你会有疑问，Virtual Dom不就是为了解决真实Dom带来的弊端吗？使用Vapor Mode不是又绕回去了吗？

> **其实不是的**
>
> Vapor Mode 并不是简单的“直接改 DOM”，它本质上是**编译时优化 + 运行时直写 DOM**的结合：
>
> - **编译时分析**
>    Vue 3.6 在编译 `.vue` 文件时，会静态分析模板，把静态节点、动态节点、绑定关系全部提前计算好。
>    这意味着运行时根本不需要 Diff 整棵树，而是精确知道：
>
>   > 哪个数据变了 → 会影响哪几个 DOM 节点 → 直接改这些节点属性/内容
>
> - **按需更新真实 DOM**
>    因为编译阶段已经知道更新路径，所以它不需要像传统 Virtual DOM 那样重新生成和比较整棵树，而是直接去改那几个节点，避免了 VDOM 构建和 Diff 的开销。
>
> - **依赖追踪依旧存在**
>    Vapor Mode 依旧保留了 Vue 的响应式系统（基于 Proxy 的依赖收集），所以不会像手写原生 DOM 那样容易“漏更新”。
>    你写的 `count++`，Vue 知道它影响到哪一段模板，直接改那一段 DOM。

![img](https://oss.yanquankun.cn/oss-cdn/img/raw.png!watermark)