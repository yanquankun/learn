### ESM注意点

1. **尽量导出不可变值**

当导出一个内容时，尽量保证该内容是不可变的（大部分情况都是如此）

因为，虽然导入后，无法更改导入内容，但是在导入的模块内部却有可能发生更改，这将导致一些无法预料的事情发生

1. **可以使用无绑定的导入用于执行一些初始化代码**

如果我们只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入：

```javascript
import "模块路径"
```

1. **可以使用绑定再导出，来重新导出来自另一个模块的内容**

有的时候，我们可能需要用一个模块封装多个模块，然后有选择的将多个模块的内容分别导出，可以使用下面的语法轻松完成

```javascript
export {绑定的标识符} from "模块路径"
```

![img](https://oss.yanquankun.cn/oss-cdn/2019-12-04-14-33-14.png!watermark)

---

### ESM深入了解

#### 导入机制的底层原理

1. **静态分析**：ESM的import机制是基于静态分析的，这意味着模块的依赖关系在编译时就已经确定，而不是在运行时。这使得工具（如Webpack、Rollup）可以进行更好的代码优化和打包。
2. **作用域隔离**：每个ESM模块都有自己的独立作用域，模块之间的变量不会相互污染。这是通过创建一个新的模块环境来实现的。
3. **按需加载**：ESM支持按需加载，即只有在模块被实际使用时才会加载。这种特性有助于减少初始加载时间，提高应用性能。
4. **单一实例**：每个模块在整个应用程序中只有一个实例（单例模式），即使被多次导入，也只会执行一次。这是通过模块缓存机制实现的。

#### 动态 import() 的原理与实现

##### 执行时解析

- **延迟解析**：动态 import() 在代码执行到该语句时才开始解析模块标识符
- **动态模块路径**：可以使用变量或表达式计算模块路径
- **条件加载**：可以在条件语句内部使用，实现按需加载

##### 异步加载过程

1. **触发加载**：执行到 import() 调用时，开始异步加载过程
2. **模块解析**：解析模块路径，获取模块文件
3. **创建模块实例**：如果模块已经被加载过，则复用已有模块实例（模块单例）
4. **返回 Promise**：加载成功后，Promise resolve 一个包含所有导出的模块对象

### 模块缓存机制

无论是静态 import 还是动态 import()，加载过的模块都会被缓存：

- **模块实例唯一性**：每个模块在应用中只有一个实例
- **缓存标识**：基于模块的绝对URL/路径
- **缓存生命周期**：在页面/应用生命周期内持续有效

### 性能考量

ESM 的性能特点：

- **并行加载**：多个模块可以并行加载，减少加载时间
- **静态优化**：由于静态分析，可以进行更有效的代码分割和优化
- **缓存利用**：模块缓存可以显著提高重复加载性能
- **预加载与预连接**：可以使用 `<link rel="modulepreload">` 预加载关键模块

使用实践：

- **合理使用动态导入**：仅在真正需要按需加载时使用动态导入
- **路径清晰化**：使用明确的路径，避免过于复杂的动态构建路径
- **代码分割策略**：基于路由或功能特性进行合理的代码分割
- **错误处理**：为动态导入添加适当的错误处理

```javascript
import('./large-module.js')
  .then(module => {
    // 使用模块
  })
  .catch(error => {
    console.error('模块加载失败:', error);
    // 提供备用方案或用户提示
  });
```

