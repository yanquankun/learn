/**
 * 2024-06-24 14:28:06
 * @author Mint.Yan
 * @description 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合
 *  输入：n = 3
    输出：[
            "((()))",
            "(()())",
            "(())()",
            "()(())",
            "()()()"
       ]
 * @param {Number} n 有效括号对数
 * @return {Array<string>} 有效括号结果
*/
const generateParenthesis = function (n) {
  // 核心思路是利用回溯法
  // 回溯的退出条件：
  //    1.左括号数目等于右括号数目
  //    2.左括号数目 + 右括号数目 = 2 * n
  // 回溯递归退出条件：
  //    当 l < r 时 剪枝
  const res = [];
  /**
   * @param l 左括号已经用了几个
   * @param r 右括号已经用了几个
   * @param str 当前递归得到的拼接字符串结果
   */
  function dfs(l, r, str) {
    if (l == n && r == n) {
      return res.push(str);
    }
    // l 小于 r 时不满足条件 剪枝
    if (l < r) {
      return;
    }
    // l 小于 n 时可以插入左括号，最多可以插入 n 个
    if (l < n) {
      dfs(l + 1, r, str + "(");
    }
    // r < l 时 可以插入右括号
    if (r < l) {
      dfs(l, r + 1, str + ")");
    }
  }
  dfs(0, 0, "");
  return res;
};
//====== 测试区域开始 ======
console.log(generateParenthesis(3));
// [ '((()))', '(()())', '(())()', '()(())', '()()()' ]
console.log(generateParenthesis(5));
// [
//   "((((()))))",
//   "(((()())))",
//   "(((())()))",
//   "(((()))())",
//   "(((())))()",
//   "((()(())))",
//   "((()()()))",
//   "((()())())",
//   "((()()))()",
//   "((())(()))",
//   "((())()())",
//   "((())())()",
//   "((()))(())",
//   "((()))()()",
//   "(()((())))",
//   "(()(()()))",
//   "(()(())())",
//   "(()(()))()",
//   "(()()(()))",
//   "(()()()())",
//   "(()()())()",
//   "(()())(())",
//   "(()())()()",
//   "(())((()))",
//   "(())(()())",
//   "(())(())()",
//   "(())()(())",
//   "(())()()()",
//   "()(((())))",
//   "()((()()))",
//   "()((())())",
//   "()((()))()",
//   "()(()(()))",
//   "()(()()())",
//   "()(()())()",
//   "()(())(())",
//   "()(())()()",
//   "()()((()))",
//   "()()(()())",
//   "()()(())()",
//   "()()()(())",
//   "()()()()()",
// ];
//====== 测试区域结束 ======
