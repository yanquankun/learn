```javascript
/**
 * 2024-10-21 11:35:30
 * @author Mint.Yan
 * @description 任务调度器
 *      Scheduler 是一个专门用于异步任务的调度器。
 *      Scheduler.postTask() 将任务作为回调添加到调度程序，可选择指定优先级、延迟和/或中止任务的信号。
 *      Scheduler.yield() 将主线程的控制权交还给浏览器，返回一个承诺，承诺从中断的地方继续执行。
 * @link https://developer.mozilla.org/en-US/docs/Web/API/Scheduler
 */
```

### setTimeout

- 在处理长任务时，使用 setTimeout 可以将任务分割成多个小任务，避免阻塞主线程。每个小任务可以在指定的延迟后执行，从而允许浏览器在任务之间处理其他事件。
- 但是，setTimeout 的延迟时间并不精确，可能会因为主线程的繁忙而导致任务执行的延迟。

### Scheduler.yield()

- Scheduler.yield() 允许开发者在长任务中主动交还控制权给浏览器，使得浏览器可以在任务执行期间处理其他重要的操作（如用户输入、渲染等）。

- 这种方法可以提高应用的响应性，尤其是在需要执行大量计算或处理时。

```javascript
// 使用 setTimeout 处理长任务
function longTaskWithSetTimeout() {
  console.log("开始长任务");
  const totalSteps = 10;

  for (let i = 0; i < totalSteps; i++) {
    setTimeout(() => {
      console.log(`步骤 ${i + 1} 完成`);
    }, 0); // 将每个步骤添加到事件队列
  }
  console.log("长任务已分割为多个小任务");
}

// 使用 Scheduler.yield 处理长任务
async function longTaskWithSchedulerYield() {
  console.log("开始长任务");
  const totalSteps = 10;

  for (let i = 0; i < totalSteps; i++) {
    await Scheduler.yield(); // 交还控制权
    console.log(`步骤 ${i + 1} 完成`);
  }
  console.log("长任务已完成");
}

// 调用示例
longTaskWithSetTimeout();
longTaskWithSchedulerYield();
```

`总结`
- `使用 setTimeout 可以将长任务分割成多个小任务，允许浏览器在任务之间处理其他事件，但可能会导致不精确的延迟。`
- `使用 Scheduler.yield() 可以在长任务中主动交还控制权，提高应用的响应性，适合需要频繁更新界面的场景。`
- **由于scheduler的兼容性并不完善，在使用时，需要先判断下当前环境是否存在scheduler**
